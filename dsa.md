# BST二叉搜索树

### 二叉树和二叉搜索树的概念

#### 二分搜索

在有序数组中查找元素，二分搜索是个不错的选择。二分搜索的搜索逻辑其实就是一个二叉搜索树。每次的搜索路径便是从根节点开始往叶子结点。其执行逻辑如图：

![](C:\Users\Mr.Helen\AppData\Roaming\Typora\typora-user-images\image-20240723170214370.png)

#### 二叉树相关概念

| 名词概念                             | 图中示例                  |
| ------------------------------------ | ------------------------- |
| 根节点                               | 58                        |
| 左/右孩子                            | 58的左/右孩子分别为24和67 |
| 双亲节点：一般简称父节点             | 24和67的父节点为58        |
| 爷爷节点：父节点的父节点             | 64的爷爷节点是67          |
| 兄弟节点：具有同一个父节点           | 24和67互为兄弟节点        |
| 叔叔节点：爷爷节点的另外一个孩子节点 | 0的叔叔节点是67           |
| 叶子节点：二叉树最后一层             | 5、41、64、78均为叶子节点 |
| 二叉树的高度/层数                    | 图中二叉树为4层           |

根节点和叶子节点比较特殊：根节点没有父节点，叶子结点没有孩子。

#### 二叉搜索树

满足`左孩子的值 < 当前节点的值 < 右孩子的值(节点不为空的情况下)`这一条件的二叉树叫做二叉搜索树(BST, Binary Search Tree)。

#### 二叉树层数和元素个数的关系

| 二叉树层数L | 二叉树一层的元素个数n=2^(L-1) |
| ----------- | ----------------------------- |
| 1           | 1                             |
| 2           | 2                             |
| 3           | 4                             |
| 4           | 8                             |

注：二叉树一层的元素个数=2^(L-1)为约等于，因为这里只是考虑了节点均有两个孩子的情况。

假设元素总个数为N，那么层数和个数关系如下

```
2^0 + 2^1 + ... + 2^(L-1) = N
2^L - 1 = N
L = log(N)
```

二分搜索的时间复杂度为时间复杂度是log(N)，正是因为其核心是在搜索二叉树。

### BST相关操作（非递归）

注：二叉树没有像链表一样定义头结点的说法，而是定义一个root指针并指向根节点，如果没有根节点则指向空。

#### 插入操作

- 当BST为空时，那么直接插入一个新节点即可，并让root指针指向新节点。
- 当BST不为空时，那么就需要从根节点开始搜索，一直搜索到叶子节点。如果`将插入的节点的值 > 叶子节点的值`那么将其插入到叶子节点的右孩子，反之插入到左孩子。

#### 删除操作

删除一个节点时，需要考虑三种情况：

1. 当前节点没有孩子时，将其父节点的孩子域置为空并删除当前节点即可。
2. 当前节点只有一个孩子时，将其父节点的孩子域置为当前节点的孩子并删除当前节点。
3. 当前节点有两个孩子时，找到其前驱节点或后继节点并用前驱(后继)节点覆盖掉当前节点，然后删除前驱(后继)节点。

注：删除前驱或后继其实是前两种情况的范畴，因为前驱或后继节点一定最多只有一个孩子节点。然后第一种情况其实类似于孩子节点为空的第二种情况。所以代码处理逻辑为----先处理第三种情况，然后再将第一和第二种情况合并在一起处理。

**前驱和后继节点：**

- 前驱节点：当前节点的左子树中值最大的节点
- 后继节点：当前节点的右子树中值最小的节点

举例：查找前驱节点，只需要从当前节点的左孩子开始查找，一直搜索其右孩子，假如此时的节点的右孩子为空，那么此时的节点就是前驱节点，后继节点的查找同理。

**为什么必须用前驱和后继节点覆盖被删除的节点：**

因为无论是前驱还是后继，当用其来覆盖被删除节点时，都不会影响bst的性质。

#### 查询操作

这个就很简单了，其实插入和删除的代码中已经用到了查询操作。核心就是从根节点开始查询元素，直到查询到叶子节点。