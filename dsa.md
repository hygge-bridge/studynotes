# 二叉树和二叉搜索树(BST)

### 二叉树和二叉搜索树的概念

#### 二分搜索

在有序数组中查找元素，二分搜索是个不错的选择。二分搜索的搜索逻辑其实就是一个二叉搜索树。每次的搜索路径便是从根节点开始往叶子结点。其执行逻辑如图：

![](C:\Users\Mr.Helen\AppData\Roaming\Typora\typora-user-images\image-20240723170214370.png)

#### 二叉树相关概念

| 名词概念                             | 图中示例                  |
| ------------------------------------ | ------------------------- |
| 根节点                               | 58                        |
| 左/右孩子                            | 58的左/右孩子分别为24和67 |
| 双亲节点：一般简称父节点             | 24和67的父节点为58        |
| 爷爷节点：父节点的父节点             | 64的爷爷节点是67          |
| 兄弟节点：具有同一个父节点           | 24和67互为兄弟节点        |
| 叔叔节点：爷爷节点的另外一个孩子节点 | 0的叔叔节点是67           |
| 叶子节点：二叉树最后一层             | 5、41、64、78均为叶子节点 |
| 二叉树的高度/层数                    | 图中二叉树为4层           |

根节点和叶子节点比较特殊：根节点没有父节点，叶子结点没有孩子。

#### 二叉搜索树

满足`左孩子的值 < 当前节点的值 < 右孩子的值(节点不为空的情况下)`这一条件的二叉树叫做二叉搜索树(BST, Binary Search Tree)。

#### 二叉树层数和元素个数的关系

| 二叉树层数L | 二叉树一层的元素个数n=2^(L-1) |
| ----------- | ----------------------------- |
| 1           | 1                             |
| 2           | 2                             |
| 3           | 4                             |
| 4           | 8                             |

注：二叉树一层的元素个数=2^(L-1)为约等于，因为这里只是考虑了节点均有两个孩子的情况。

假设元素总个数为N，那么层数和个数关系如下

```
2^0 + 2^1 + ... + 2^(L-1) = N
2^L - 1 = N
L = log(N)
```

二分搜索的时间复杂度为时间复杂度是log(N)，正是因为其核心是在搜索二叉树。

### BST增删查操作（非递归）

注：二叉树没有像链表一样定义头结点的说法，而是定义一个root指针并指向根节点，如果没有根节点则指向空。

#### 插入操作

- 当BST为空时，那么直接插入一个新节点即可，并让root指针指向新节点。
- 当BST不为空时，那么就需要从根节点开始搜索，一直搜索到叶子节点。如果`将插入的节点的值 > 叶子节点的值`那么将其插入到叶子节点的右孩子，反之插入到左孩子。

#### 删除操作

删除一个节点时，需要考虑三种情况：

1. 当前节点没有孩子时，将其父节点的孩子域置为空并删除当前节点即可。
2. 当前节点只有一个孩子时，将其父节点的孩子域置为当前节点的孩子并删除当前节点。
3. 当前节点有两个孩子时，找到其前驱节点或后继节点并用前驱(后继)节点覆盖掉当前节点，然后删除前驱(后继)节点。

注：删除前驱或后继其实是前两种情况的范畴，因为前驱或后继节点一定最多只有一个孩子节点。然后第一种情况其实类似于孩子节点为空的第二种情况。所以代码处理逻辑为----先处理第三种情况，然后再将第一和第二种情况合并在一起处理。

**前驱和后继节点：**

- 前驱节点：当前节点的左子树中值最大的节点
- 后继节点：当前节点的右子树中值最小的节点

举例：查找前驱节点，只需要从当前节点的左孩子开始查找，一直搜索其右孩子，假如此时的节点的右孩子为空，那么此时的节点就是前驱节点，后继节点的查找同理。

**为什么必须用前驱和后继节点覆盖被删除的节点：**

因为无论是前驱还是后继，当用其来覆盖被删除节点时，都不会影响bst的性质。

#### 查询操作

这个就很简单了，其实插入和删除的代码中已经用到了查询操作。核心就是从根节点开始查询元素，直到查询到叶子节点。

### BST增删查操作（递归）

思想和非递归版本大致相同，唯一不同的点在于插入元素时，需要将新节点链接到树上，在递归中就需要在回溯时实现该步骤。删除操作同理。

### 二叉树的遍历（递归）

#### 前中后序遍历

假设当前节点为v，左孩子为l，右孩子为r。规定l必须出现在r前面，那么根据v的位置就会出现三种遍历方式：前序遍历(vlr)、中序遍历(lvr)、后序遍历(lrv)。

注：前中后序遍历是每一个节点都按照这种方式遍历。一眼深度遍历，所以它们使用递归实现非常简单。核心就是如下代码，只需要合理选择v的位置即可：

```c++
void Traverse(Node* node) {
	if (node) {
		...
		Traverse(node->left);  // l
		...
		Traverse(node->right); // r
		...
	}
}
```

#### 层序遍历

层序遍历属于广度遍历，所以其实不适合使用递归实现，因为递归其实是深度遍历。但是非要用递归也不是不行。因为递归也会遍历完所有的元素，那么我们只需要控制递归的深度，递归到一层时就结束递归，然后一共二叉树有多少层就进行多少次递归即可。

### 二叉树的遍历（非递归）

对于前中后序遍历就是利用栈来模拟深度遍历的过程，而层序遍历就是利用队列来模拟广度遍历的过程。只看思路容易一头雾水，建议看代码理解。

#### 前序遍历

vlr。为了记录当前节点的右孩子，所以入栈顺序应该为当前节点的右孩子，左孩子。然后出栈，此时获得的栈顶元素就是v。按照这个顺序就可以得到结果。

#### 中序遍历

lvr。首先将当前节点的左孩子全部入栈，然后出栈(v)，最后将右孩子入栈。

#### 后序遍历

lrv。因为需要把l和r全部遍历完才可以打印v，所以很难定位到v的位置。为了方便处理，采用vrl的方式遍历，然后将结果逆序输出即可。方式和前序遍历雷同。

#### 层序遍历

将当前节点的左孩子和右孩子入队列，然后每次取队头元素打印就可以了。

### 二叉树的析构函数

因为需要删除所有的节点，所以无法使用递归方式来遍历二叉树，通过非递归方式来遍历二叉树的同时删除掉节点即可。常见的是通过层次遍历来删除。

### 相关算法题

#### BST区间搜索问题

`问题：在bst中，搜索指定区间内的元素。如搜索[10,40]之间的元素表示搜索bst中值在10到40之间的元素，包含10和40`

笨办法：遍历bst，然后将指定范围的节点提取出来。缺点---就算区间范围很小，也需要遍历整个bst。（不可取）

方法：利用bst中序遍历是升序的特点，在进行中序遍历的过程中就可以提取元素，并且如果元素已经超出范围那么便结束遍历（类似于剪枝）。

#### 判断二叉树是否是bst问题

`问题：判断一个二叉树是不是bst`

bst的特点：

1. 节点的左孩子一定小于当前节点，右孩子一定大于当前节点
2. 节点的左子树的所有值都小于当前节点，右子树的所有值都大于当前节点（注意，很多人都会忽略这个特点）

很多人第一时间可能会想到遍历二叉树然后，判断当前节点的左右孩子即可，但是这种做法会忽略掉第二个特点。所以不可取。

正确的做法是，利用bst中序遍历是升序的特点，对二叉树进行中序遍历，然后判断当前节点是否大于前一个节点就好了。

一个中序遍历是升序的二叉树一定是bst，大家可以自己举例子验证一下。

#### 二叉树子树问题

`问题：判断一个小二叉树是不是大二叉树的子树`

首先去大二叉树汇总寻找小二叉树的根节点，找到后，两棵树采用相同的方式遍历，如果出现了某一次的节点值不同那么就不是大二叉树的子树。注意小二叉树如果为空，那么也算是子树。

#### BST中最近公共祖先节点(LCA)问题

`问题：寻找二叉树中指定节点的最近公共祖先节点`

LCA是指两个节点往根节点走，走到最先相同的那个节点就是LCA。

根据bst的特性，可知lca一定是大于一个节点且小于一个节点的。 那么遍历bst找满足要求的就好了。

#### 二叉树镜像翻转问题

`问题：将二叉树镜像翻转`

很简单，遍历二叉树，然后把每个节点的左右孩子交换。

#### 二叉树镜像对称问题

`问题：判断一个二叉树是否镜像对称`

遍历二叉树，然后判断当前节点是否相同，往下遍历时需要判断的是节点1的左孩子和节点2的右孩子是否相同，节点1的右孩子和节点2的左孩子是否相同。毕竟是镜像对称嘛。

#### 根据前序遍历和中序遍历重建二叉树问题

`问题：根据前序遍历和中序遍历的结果重新构建出二叉树`

通过前序遍历可以知道第一个节点是根节点，然后去中序遍历找到根节点的位置。那么就相当于知道了左子树的节点范围和右子树的节点范围。递归走下去即可。这个问题的核心是递归时传入的范围不能出错。

#### 判断二叉树是否是平衡二叉树(AVL)问题

`问题：判断二叉树是否是平衡二叉树(AVL)`

AVL：节点的左孩子和右孩子的高数差不能超过1。

我们需要判断二叉树的每一个节点的左右孩子的高度差，假如先递归判断然后单独计算高度的话，效率太低了。正确做法是在递归判断的同时记录二叉树的高度。注意函数返回该节点的孩子高度时，需要返回左右子树中更高的那一个，毕竟我们主要是判断不满足AVL特性的情况。

#### 求中序遍历倒数第k个节点问题

`问题：求中序遍历倒数第k个节点`

笨方法：先遍历一遍二叉树求出节点个数n，然后中序遍历到第n-k+1个节点就是倒是第k个节点了。遍历了两次二叉树，效率低。

其实中序遍历是lvr，那么rvl就是倒序结果，取rvl的结果中遍历第k-1个节点就好了。（注意倒序是从1开始计数而正序是从0开始计数，所以正序时只需要遍历k-1个节点）。
